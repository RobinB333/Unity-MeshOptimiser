using System;
using System.Runtime.InteropServices;

namespace Evergine.Bindings.MeshOptimizer
{
	public static unsafe partial class MeshOptNative
	{
		/// <summary>
		/// Generates a vertex remap table from the vertex buffer and an optional index buffer and returns number of unique vertices
		/// As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
		/// Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
		/// Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
		/// destination must contain enough space for the resulting remap table (vertex_count elements)
		/// indices can be NULL if the input is unindexed
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_generateVertexRemap(uint* destination, uint* indices, UIntPtr index_count, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size);

		/// <summary>
		/// Generates a vertex remap table from multiple vertex streams and an optional index buffer and returns number of unique vertices
		/// As a result, all vertices that are binary equivalent map to the same (new) location, with no gaps in the resulting sequence.
		/// Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer/meshopt_remapIndexBuffer.
		/// To remap vertex buffers, you will need to call meshopt_remapVertexBuffer for each vertex stream.
		/// Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
		/// destination must contain enough space for the resulting remap table (vertex_count elements)
		/// indices can be NULL if the input is unindexed
		/// stream_count must be 
		/// <
		/// = 16
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_generateVertexRemapMulti(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count, meshopt_Stream* streams, UIntPtr stream_count);

		/// <summary>
		/// Generates vertex buffer from the source vertex buffer and remap table generated by meshopt_generateVertexRemap
		/// destination must contain enough space for the resulting vertex buffer (unique_vertex_count elements, returned by meshopt_generateVertexRemap)
		/// vertex_count should be the initial vertex count and not the value returned by meshopt_generateVertexRemap
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_remapVertexBuffer(void* destination, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size, uint* remap);

		/// <summary>
		/// Generate index buffer from the source index buffer and remap table generated by meshopt_generateVertexRemap
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// indices can be NULL if the input is unindexed
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_remapIndexBuffer(uint* destination, uint* indices, UIntPtr index_count, uint* remap);

		/// <summary>
		/// Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
		/// All vertices that are binary equivalent (wrt first vertex_size bytes) map to the first vertex in the original vertex buffer.
		/// This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
		/// Note that binary equivalence considers all vertex_size bytes, including padding which should be zero-initialized.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_generateShadowIndexBuffer(uint* destination, uint* indices, UIntPtr index_count, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size, UIntPtr vertex_stride);

		/// <summary>
		/// Generate index buffer that can be used for more efficient rendering when only a subset of the vertex attributes is necessary
		/// All vertices that are binary equivalent (wrt specified streams) map to the first vertex in the original vertex buffer.
		/// This makes it possible to use the index buffer for Z pre-pass or shadowmap rendering, while using the original index buffer for regular rendering.
		/// Note that binary equivalence considers all size bytes in each stream, including padding which should be zero-initialized.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// stream_count must be 
		/// <
		/// = 16
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_generateShadowIndexBufferMulti(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count, meshopt_Stream* streams, UIntPtr stream_count);

		/// <summary>
		/// Generate index buffer that can be used as a geometry shader input with triangle adjacency topology
		/// Each triangle is converted into a 6-vertex patch with the following layout:
		/// - 0, 2, 4: original triangle vertices
		/// - 1, 3, 5: vertices adjacent to edges 02, 24 and 40
		/// The resulting patch can be rendered with geometry shaders using e.g. VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY.
		/// This can be used to implement algorithms like silhouette detection/expansion and other forms of GS-driven rendering.
		/// destination must contain enough space for the resulting index buffer (index_count*2 elements)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_generateAdjacencyIndexBuffer(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Generate index buffer that can be used for PN-AEN tessellation with crack-free displacement
		/// Each triangle is converted into a 12-vertex patch with the following layout:
		/// - 0, 1, 2: original triangle vertices
		/// - 3, 4: opposing edge for edge 0, 1
		/// - 5, 6: opposing edge for edge 1, 2
		/// - 7, 8: opposing edge for edge 2, 0
		/// - 9, 10, 11: dominant vertices for corners 0, 1, 2
		/// The resulting patch can be rendered with hardware tessellation using PN-AEN and displacement mapping.
		/// See "Tessellation on Any Budget" (John McDonald, GDC 2011) for implementation details.
		/// destination must contain enough space for the resulting index buffer (index_count*4 elements)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_generateTessellationIndexBuffer(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Experimental: Generate index buffer that can be used for visibility buffer rendering and returns the size of the reorder table
		/// Each triangle's provoking vertex index is equal to primitive id; this allows passing it to the fragment shader using nointerpolate attribute.
		/// This is important for performance on hardware where primitive id can't be accessed efficiently in fragment shader.
		/// The reorder table stores the original vertex id for each vertex in the new index buffer, and should be used in the vertex shader to load vertex data.
		/// The provoking vertex is assumed to be the first vertex in the triangle; if this is not the case (OpenGL), rotate each triangle (abc -> bca) before rendering.
		/// For maximum efficiency the input index buffer should be optimized for vertex cache first.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// reorder must contain enough space for the worst case reorder table (vertex_count + index_count/3 elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_generateProvokingIndexBuffer(uint* destination, uint* reorder, uint* indices, UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Vertex transform cache optimizer
		/// Reorders indices to reduce the number of GPU vertex shader invocations
		/// If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_optimizeVertexCache(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Vertex transform cache optimizer for strip-like caches
		/// Produces inferior results to meshopt_optimizeVertexCache from the GPU vertex cache perspective
		/// However, the resulting index order is more optimal if the goal is to reduce the triangle strip length or improve compression efficiency
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_optimizeVertexCacheStrip(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Vertex transform cache optimizer for FIFO caches
		/// Reorders indices to reduce the number of GPU vertex shader invocations
		/// Generally takes ~3x less time to optimize meshes but produces inferior results compared to meshopt_optimizeVertexCache
		/// If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// cache_size should be less than the actual GPU cache size to avoid cache thrashing
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_optimizeVertexCacheFifo(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count, uint cache_size);

		/// <summary>
		/// Overdraw optimizer
		/// Reorders indices to reduce the number of GPU vertex shader invocations and the pixel overdraw
		/// If index buffer contains multiple ranges for multiple draw calls, this functions needs to be called on each range individually.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// indices must contain index data that is the result of meshopt_optimizeVertexCache (*not* the original mesh indices!)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// threshold indicates how much the overdraw optimizer can degrade vertex cache efficiency (1.05 = up to 5%) to reduce overdraw more efficiently
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_optimizeOverdraw(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, float threshold);

		/// <summary>
		/// Vertex fetch cache optimizer
		/// Reorders vertices and changes indices to reduce the amount of GPU memory fetches during vertex processing
		/// Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
		/// This functions works for a single vertex stream; for multiple vertex streams, use meshopt_optimizeVertexFetchRemap + meshopt_remapVertexBuffer for each stream.
		/// destination must contain enough space for the resulting vertex buffer (vertex_count elements)
		/// indices is used both as an input and as an output index buffer
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_optimizeVertexFetch(void* destination, uint* indices, UIntPtr index_count, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size);

		/// <summary>
		/// Vertex fetch cache optimizer
		/// Generates vertex remap to reduce the amount of GPU memory fetches during vertex processing
		/// Returns the number of unique vertices, which is the same as input vertex count unless some vertices are unused
		/// The resulting remap table should be used to reorder vertex/index buffers using meshopt_remapVertexBuffer/meshopt_remapIndexBuffer
		/// destination must contain enough space for the resulting remap table (vertex_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_optimizeVertexFetchRemap(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Index buffer encoder
		/// Encodes index data into an array of bytes that is generally much smaller (
		/// <
		/// 1.5 bytes/triangle) and compresses better (
		/// <
		/// 1 bytes/triangle) compared to original.
		/// Input index buffer must represent a triangle list.
		/// Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
		/// For maximum efficiency the index buffer being encoded has to be optimized for vertex cache and vertex fetch first.
		/// buffer must contain enough space for the encoded index buffer (use meshopt_encodeIndexBufferBound to compute worst case size)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeIndexBuffer(byte* buffer, UIntPtr buffer_size, uint* indices, UIntPtr index_count);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeIndexBufferBound(UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Set index encoder format version
		/// version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.14+)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_encodeIndexVersion(int version);

		/// <summary>
		/// Index buffer decoder
		/// Decodes index data from an array of bytes generated by meshopt_encodeIndexBuffer
		/// Returns 0 if decoding was successful, and an error code otherwise
		/// The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern int meshopt_decodeIndexBuffer(void* destination, UIntPtr index_count, UIntPtr index_size, byte* buffer, UIntPtr buffer_size);

		/// <summary>
		/// Get encoded index format version
		/// Returns format version of the encoded index buffer/sequence, or -1 if the buffer header is invalid
		/// Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed.
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern int meshopt_decodeIndexVersion(byte* buffer, UIntPtr buffer_size);

		/// <summary>
		/// Index sequence encoder
		/// Encodes index sequence into an array of bytes that is generally smaller and compresses better compared to original.
		/// Input index sequence can represent arbitrary topology; for triangle lists meshopt_encodeIndexBuffer is likely to be better.
		/// Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
		/// buffer must contain enough space for the encoded index sequence (use meshopt_encodeIndexSequenceBound to compute worst case size)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeIndexSequence(byte* buffer, UIntPtr buffer_size, uint* indices, UIntPtr index_count);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeIndexSequenceBound(UIntPtr index_count, UIntPtr vertex_count);

		/// <summary>
		/// Index sequence decoder
		/// Decodes index data from an array of bytes generated by meshopt_encodeIndexSequence
		/// Returns 0 if decoding was successful, and an error code otherwise
		/// The decoder is safe to use for untrusted input, but it may produce garbage data (e.g. out of range indices).
		/// destination must contain enough space for the resulting index sequence (index_count elements)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern int meshopt_decodeIndexSequence(void* destination, UIntPtr index_count, UIntPtr index_size, byte* buffer, UIntPtr buffer_size);

		/// <summary>
		/// Vertex buffer encoder
		/// Encodes vertex data into an array of bytes that is generally smaller and compresses better compared to original.
		/// Returns encoded data size on success, 0 on error; the only error condition is if buffer doesn't have enough space
		/// This function works for a single vertex stream; for multiple vertex streams, call meshopt_encodeVertexBuffer for each stream.
		/// Note that all vertex_size bytes of each vertex are encoded verbatim, including padding which should be zero-initialized.
		/// For maximum efficiency the vertex buffer being encoded has to be quantized and optimized for locality of reference (cache/fetch) first.
		/// buffer must contain enough space for the encoded vertex buffer (use meshopt_encodeVertexBufferBound to compute worst case size)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeVertexBuffer(byte* buffer, UIntPtr buffer_size, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeVertexBufferBound(UIntPtr vertex_count, UIntPtr vertex_size);

		/// <summary>
		/// Experimental: Vertex buffer encoder
		/// Encodes vertex data just like meshopt_encodeVertexBuffer, but allows to override compression level.
		/// For compression level to take effect, the vertex encoding version must be set to 1 via meshopt_encodeVertexVersion.
		/// The default compression level implied by meshopt_encodeVertexBuffer is 2.
		/// level should be in the range [0, 3] with 0 being the fastest and 3 being the slowest and producing the best compression ratio.
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_encodeVertexBufferLevel(byte* buffer, UIntPtr buffer_size, void* vertices, UIntPtr vertex_count, UIntPtr vertex_size, int level);

		/// <summary>
		/// Set vertex encoder format version
		/// version must specify the data format version to encode; valid values are 0 (decodable by all library versions) and 1 (decodable by 0.23+)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_encodeVertexVersion(int version);

		/// <summary>
		/// Vertex buffer decoder
		/// Decodes vertex data from an array of bytes generated by meshopt_encodeVertexBuffer
		/// Returns 0 if decoding was successful, and an error code otherwise
		/// The decoder is safe to use for untrusted input, but it may produce garbage data.
		/// destination must contain enough space for the resulting vertex buffer (vertex_count * vertex_size bytes)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern int meshopt_decodeVertexBuffer(void* destination, UIntPtr vertex_count, UIntPtr vertex_size, byte* buffer, UIntPtr buffer_size);

		/// <summary>
		/// Get encoded vertex format version
		/// Returns format version of the encoded vertex buffer, or -1 if the buffer header is invalid
		/// Note that a non-negative value doesn't guarantee that the buffer will be decoded correctly if the input is malformed.
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern int meshopt_decodeVertexVersion(byte* buffer, UIntPtr buffer_size);

		/// <summary>
		/// Vertex buffer filters
		/// These functions can be used to filter output of meshopt_decodeVertexBuffer in-place.
		/// meshopt_decodeFilterOct decodes octahedral encoding of a unit vector with K-bit (K 
		/// <
		/// = 16) signed X/Y as an input; Z must store 1.0f.
		/// Each component is stored as an 8-bit or 16-bit normalized integer; stride must be equal to 4 or 8. W is preserved as is.
		/// meshopt_decodeFilterQuat decodes 3-component quaternion encoding with K-bit (4 
		/// <
		/// = K 
		/// <
		/// = 16) component encoding and a 2-bit component index indicating which component to reconstruct.
		/// Each component is stored as an 16-bit integer; stride must be equal to 8.
		/// meshopt_decodeFilterExp decodes exponential encoding of floating-point data with 8-bit exponent and 24-bit integer mantissa as 2^E*M.
		/// Each 32-bit component is decoded in isolation; stride must be divisible by 4.
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_decodeFilterOct(void* buffer, UIntPtr count, UIntPtr stride);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_decodeFilterQuat(void* buffer, UIntPtr count, UIntPtr stride);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_decodeFilterExp(void* buffer, UIntPtr count, UIntPtr stride);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_encodeFilterOct(void* destination, UIntPtr count, UIntPtr stride, int bits, float* data);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_encodeFilterQuat(void* destination, UIntPtr count, UIntPtr stride, int bits, float* data);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_encodeFilterExp(void* destination, UIntPtr count, UIntPtr stride, int bits, float* data, meshopt_EncodeExpMode mode);

		/// <summary>
		/// Mesh simplifier
		/// Reduces the number of triangles in the mesh, attempting to preserve mesh appearance as much as possible
		/// The algorithm tries to preserve mesh topology and can stop short of the target goal based on topology constraints or target error.
		/// If not all attributes from the input mesh are required, it's recommended to reindex the mesh without them prior to simplification.
		/// Returns the number of indices after simplification, with destination containing new index data
		/// The resulting index buffer references vertices from the original vertex buffer.
		/// If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
		/// destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
		/// options must be a bitmask composed of meshopt_SimplifyX options; 0 is a safe default
		/// result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_simplify(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, UIntPtr target_index_count, float target_error, uint options, float* result_error);

		/// <summary>
		/// Mesh simplifier with attribute metric
		/// The algorithm enhances meshopt_simplify by incorporating attribute values into the error metric used to prioritize simplification order; see meshopt_simplify documentation for details.
		/// Note that the number of attributes affects memory requirements and running time; this algorithm requires ~1.5x more memory and time compared to meshopt_simplify when using 4 scalar attributes.
		/// vertex_attributes should have attribute_count floats for each vertex
		/// attribute_weights should have attribute_count floats in total; the weights determine relative priority of attributes between each other and wrt position
		/// attribute_count must be 
		/// <
		/// = 32
		/// vertex_lock can be NULL; when it's not NULL, it should have a value for each vertex; 1 denotes vertices that can't be moved
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_simplifyWithAttributes(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, float* vertex_attributes, UIntPtr vertex_attributes_stride, float* attribute_weights, UIntPtr attribute_count, byte* vertex_lock, UIntPtr target_index_count, float target_error, uint options, float* result_error);

		/// <summary>
		/// Experimental: Mesh simplifier (sloppy)
		/// Reduces the number of triangles in the mesh, sacrificing mesh appearance for simplification performance
		/// The algorithm doesn't preserve mesh topology but can stop short of the target goal based on target error.
		/// Returns the number of indices after simplification, with destination containing new index data
		/// The resulting index buffer references vertices from the original vertex buffer.
		/// If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
		/// destination must contain enough space for the target index buffer, worst case is index_count elements (*not* target_index_count)!
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// target_error represents the error relative to mesh extents that can be tolerated, e.g. 0.01 = 1% deformation; value range [0..1]
		/// result_error can be NULL; when it's not NULL, it will contain the resulting (relative) error after simplification
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_simplifySloppy(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, UIntPtr target_index_count, float target_error, float* result_error);

		/// <summary>
		/// Point cloud simplifier
		/// Reduces the number of points in the cloud to reach the given target
		/// Returns the number of points after simplification, with destination containing new index data
		/// The resulting index buffer references vertices from the original vertex buffer.
		/// If the original vertex data isn't required, creating a compact vertex buffer using meshopt_optimizeVertexFetch is recommended.
		/// destination must contain enough space for the target index buffer (target_vertex_count elements)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// vertex_colors can be NULL; when it's not NULL, it should have float3 color in the first 12 bytes of each vertex
		/// color_weight determines relative priority of color wrt position; 1.0 is a safe default
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_simplifyPoints(uint* destination, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, float* vertex_colors, UIntPtr vertex_colors_stride, float color_weight, UIntPtr target_vertex_count);

		/// <summary>
		/// Returns the error scaling factor used by the simplifier to convert between absolute and relative extents
		/// Absolute error must be *divided* by the scaling factor before passing it to meshopt_simplify as target_error
		/// Relative error returned by meshopt_simplify via result_error must be *multiplied* by the scaling factor to get absolute error.
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern float meshopt_simplifyScale(float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Mesh stripifier
		/// Converts a previously vertex cache optimized triangle list to triangle strip, stitching strips using restart index or degenerate triangles
		/// Returns the number of indices in the resulting strip, with destination containing new index data
		/// For maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
		/// Using restart indices can result in ~10% smaller index buffers, but on some GPUs restart indices may result in decreased performance.
		/// destination must contain enough space for the target index buffer, worst case can be computed with meshopt_stripifyBound
		/// restart_index should be 0xffff or 0xffffffff depending on index size, or 0 to use degenerate triangles
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_stripify(uint* destination, uint* indices, UIntPtr index_count, UIntPtr vertex_count, uint restart_index);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_stripifyBound(UIntPtr index_count);

		/// <summary>
		/// Mesh unstripifier
		/// Converts a triangle strip to a triangle list
		/// Returns the number of indices in the resulting list, with destination containing new index data
		/// destination must contain enough space for the target index buffer, worst case can be computed with meshopt_unstripifyBound
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_unstripify(uint* destination, uint* indices, UIntPtr index_count, uint restart_index);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_unstripifyBound(UIntPtr index_count);

		/// <summary>
		/// Vertex transform cache analyzer
		/// Returns cache hit statistics using a simplified FIFO model
		/// Results may not match actual GPU performance
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_VertexCacheStatistics meshopt_analyzeVertexCache(uint* indices, UIntPtr index_count, UIntPtr vertex_count, uint cache_size, uint warp_size, uint primgroup_size);

		/// <summary>
		/// Overdraw analyzer
		/// Returns overdraw statistics using a software rasterizer
		/// Results may not match actual GPU performance
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_OverdrawStatistics meshopt_analyzeOverdraw(uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Vertex fetch cache analyzer
		/// Returns cache hit statistics using a simplified direct mapped model
		/// Results may not match actual GPU performance
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_VertexFetchStatistics meshopt_analyzeVertexFetch(uint* indices, UIntPtr index_count, UIntPtr vertex_count, UIntPtr vertex_size);

		/// <summary>
		/// Meshlet builder
		/// Splits the mesh into a set of meshlets where each meshlet has a micro index buffer indexing into meshlet vertices that refer to the original vertex buffer
		/// The resulting data can be used to render meshes using NVidia programmable mesh shading pipeline, or in other cluster-based renderers.
		/// When targeting mesh shading hardware, for maximum efficiency meshlets should be further optimized using meshopt_optimizeMeshlet.
		/// When using buildMeshlets, vertex positions need to be provided to minimize the size of the resulting clusters.
		/// When using buildMeshletsScan, for maximum efficiency the index buffer being converted has to be optimized for vertex cache first.
		/// meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound
		/// meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
		/// meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// max_vertices and max_triangles must not exceed implementation limits (max_vertices 
		/// <
		/// = 256, max_triangles 
		/// <
		/// = 512; max_triangles must be divisible by 4)
		/// cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_buildMeshlets(meshopt_Meshlet* meshlets, uint* meshlet_vertices, byte* meshlet_triangles, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, UIntPtr max_vertices, UIntPtr max_triangles, float cone_weight);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_buildMeshletsScan(meshopt_Meshlet* meshlets, uint* meshlet_vertices, byte* meshlet_triangles, uint* indices, UIntPtr index_count, UIntPtr vertex_count, UIntPtr max_vertices, UIntPtr max_triangles);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_buildMeshletsBound(UIntPtr index_count, UIntPtr max_vertices, UIntPtr max_triangles);

		/// <summary>
		/// Experimental: Meshlet builder with flexible cluster sizes
		/// Splits the mesh into a set of meshlets, similarly to meshopt_buildMeshlets, but allows to specify minimum and maximum number of triangles per meshlet.
		/// Clusters between min and max triangle counts are split when the cluster size would have exceeded the expected cluster size by more than split_factor.
		/// Additionally, allows to switch to axis aligned clusters by setting cone_weight to a negative value.
		/// meshlets must contain enough space for all meshlets, worst case size can be computed with meshopt_buildMeshletsBound using min_triangles (not max!)
		/// meshlet_vertices must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_vertices
		/// meshlet_triangles must contain enough space for all meshlets, worst case size is equal to max_meshlets * max_triangles * 3
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// max_vertices, min_triangles and max_triangles must not exceed implementation limits (max_vertices 
		/// <
		/// = 256, max_triangles 
		/// <
		/// = 512; min_triangles 
		/// <
		/// = max_triangles; both min_triangles and max_triangles must be divisible by 4)
		/// cone_weight should be set to 0 when cone culling is not used, and a value between 0 and 1 otherwise to balance between cluster size and cone culling efficiency; additionally, cone_weight can be set to a negative value to prioritize axis aligned clusters (for raytracing) instead
		/// split_factor should be set to a non-negative value; when greater than 0, clusters that have large bounds may be split unless they are under the min_triangles threshold
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_buildMeshletsFlex(meshopt_Meshlet* meshlets, uint* meshlet_vertices, byte* meshlet_triangles, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride, UIntPtr max_vertices, UIntPtr min_triangles, UIntPtr max_triangles, float cone_weight, float split_factor);

		/// <summary>
		/// Meshlet optimizer
		/// Reorders meshlet vertices and triangles to maximize locality to improve rasterizer throughput
		/// meshlet_triangles and meshlet_vertices must refer to meshlet triangle and vertex index data; when buildMeshlets* is used, these
		/// need to be computed from meshlet's vertex_offset and triangle_offset
		/// triangle_count and vertex_count must not exceed implementation limits (vertex_count 
		/// <
		/// = 256, triangle_count 
		/// <
		/// = 512)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_optimizeMeshlet(uint* meshlet_vertices, byte* meshlet_triangles, UIntPtr triangle_count, UIntPtr vertex_count);

		/// <summary>
		/// Cluster bounds generator
		/// Creates bounding volumes that can be used for frustum, backface and occlusion culling.
		/// For backface culling with orthographic projection, use the following formula to reject backfacing clusters:
		/// dot(view, cone_axis) >= cone_cutoff
		/// For perspective projection, you can use the formula that needs cone apex in addition to axis 
		/// &
		/// cutoff:
		/// dot(normalize(cone_apex - camera_position), cone_axis) >= cone_cutoff
		/// Alternatively, you can use the formula that doesn't need cone apex and uses bounding sphere instead:
		/// dot(normalize(center - camera_position), cone_axis) >= cone_cutoff + radius / length(center - camera_position)
		/// or an equivalent formula that doesn't have a singularity at center = camera_position:
		/// dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius
		/// The formula that uses the apex is slightly more accurate but needs the apex; if you are already using bounding sphere
		/// to do frustum/occlusion culling, the formula that doesn't use the apex may be preferable (for derivation see
		/// Real-Time Rendering 4th Edition, section 19.3).
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// vertex_count should specify the number of vertices in the entire mesh, not cluster or meshlet
		/// index_count/3 and triangle_count must not exceed implementation limits (
		/// <
		/// = 512)
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_Bounds meshopt_computeClusterBounds(uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_Bounds meshopt_computeMeshletBounds(uint* meshlet_vertices, byte* meshlet_triangles, UIntPtr triangle_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Experimental: Sphere bounds generator
		/// Creates bounding sphere around a set of points or a set of spheres; returns the center and radius of the sphere, with other fields of the result set to 0.
		/// positions should have float3 position in the first 12 bytes of each element
		/// radii can be NULL; when it's not NULL, it should have a non-negative float radius in the first 4 bytes of each element
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern meshopt_Bounds meshopt_computeSphereBounds(float* positions, UIntPtr count, UIntPtr positions_stride, float* radii, UIntPtr radii_stride);

		/// <summary>
		/// Experimental: Cluster partitioner
		/// Partitions clusters into groups of similar size, prioritizing grouping clusters that share vertices.
		/// destination must contain enough space for the resulting partiotion data (cluster_count elements)
		/// destination[i] will contain the partition id for cluster i, with the total number of partitions returned by the function
		/// cluster_indices should have the vertex indices referenced by each cluster, stored sequentially
		/// cluster_index_counts should have the number of indices in each cluster; sum of all cluster_index_counts must be equal to total_index_count
		/// target_partition_size is a target size for each partition, in clusters; the resulting partitions may be smaller or larger
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern UIntPtr meshopt_partitionClusters(uint* destination, uint* cluster_indices, UIntPtr total_index_count, uint* cluster_index_counts, UIntPtr cluster_count, UIntPtr vertex_count, UIntPtr target_partition_size);

		/// <summary>
		/// Spatial sorter
		/// Generates a remap table that can be used to reorder points for spatial locality.
		/// Resulting remap table maps old vertices to new vertices and can be used in meshopt_remapVertexBuffer.
		/// destination must contain enough space for the resulting remap table (vertex_count elements)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_spatialSortRemap(uint* destination, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Experimental: Spatial sorter
		/// Reorders triangles for spatial locality, and generates a new index buffer. The resulting index buffer can be used with other functions like optimizeVertexCache.
		/// destination must contain enough space for the resulting index buffer (index_count elements)
		/// vertex_positions should have float3 position in the first 12 bytes of each vertex
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern void meshopt_spatialSortTriangles(uint* destination, uint* indices, UIntPtr index_count, float* vertex_positions, UIntPtr vertex_count, UIntPtr vertex_positions_stride);

		/// <summary>
		/// Quantize a float into half-precision (as defined by IEEE-754 fp16) floating point value
		/// Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
		/// Representable magnitude range: [6e-5; 65504]
		/// Maximum relative reconstruction error: 5e-4
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern ushort meshopt_quantizeHalf(float v);

		/// <summary>
		/// Quantize a float into a floating point value with a limited number of significant mantissa bits, preserving the IEEE-754 fp32 binary representation
		/// Generates +-inf for overflow, preserves NaN, flushes denormals to zero, rounds to nearest
		/// Assumes N is in a valid mantissa precision range, which is 1..23
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern float meshopt_quantizeFloat(float v, int N);

		/// <summary>
		/// Reverse quantization of a half-precision (as defined by IEEE-754 fp16) floating point value
		/// Preserves Inf/NaN, flushes denormals to zero
		/// </summary>
		[DllImport("meshoptimizer", CallingConvention = CallingConvention.Cdecl)]
		public static extern float meshopt_dequantizeHalf(ushort h);

	}
}
